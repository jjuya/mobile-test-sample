<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>모바일 키보드 Fixed UI 테스트</title>
    <!-- Tailwind CSS 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 'Inter' 폰트 사용 */
        html { font-family: 'Inter', sans-serif; }
        /* 전체 뷰포트 높이를 차지하되 스크롤 가능하게 설정 */
        body {
            height: 100vh;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            padding-bottom: 12rem; /* Fixed UI 공간 확보 */
        }

        /* Fixed 컨테이너는 하단에 고정되어야 하며, JS로 transform 될 예정 */
        #fixed-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            /* transform을 사용할 때 transition을 적용하여 움직임을 부드럽게 함 (성능 최적화) */
            transition: transform 0.2s ease-out;
            z-index: 50;
        }

        /* 키보드 유무 상태 메시지 */
        #status {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 60;
            font-size: 0.875rem;
        }
    </style>
</head>
<body>

    <!-- 키보드 상태 표시 (디버깅/보고용) -->
    <div id="status" class="bg-indigo-500 text-white p-2 text-center shadow-lg">
        Visual Viewport 상태 모니터링 중...
    </div>
    
    <!-- 메인 스크롤 콘텐츠 -->
    <main class="container mx-auto p-4 flex-grow">
        <h1 class="text-3xl font-bold mb-4 text-gray-800">스크롤 가능한 콘텐츠 영역</h1>
        <p class="mb-2 text-gray-600">이 영역은 Layout Viewport 내에서 자유롭게 스크롤됩니다.</p>
        <div class="space-y-4">
            <!-- 더미 콘텐츠 생성 (스크롤 유발) -->
            <div class="bg-white p-4 rounded-xl shadow-md border border-gray-100">
                <h2 class="font-semibold text-lg text-indigo-600">섹션 1: Viewport 문제의 이해</h2>
                <p class="text-sm mt-1">모바일에서 키보드가 올라오면 Visual Viewport가 축소됩니다. Fixed 요소는 이 축소된 영역에서 벗어나 키보드 아래에 가려지게 됩니다.</p>
            </div>
            <div class="bg-white p-4 rounded-xl shadow-md border border-gray-100">
                <h2 class="font-semibold text-lg text-indigo-600">섹션 2: JS 수동 조정의 필요성</h2>
                <p class="text-sm mt-1">브라우저별 Layout Viewport 동작이 달라 크로스 브라우징 호환성 확보를 위해 Visual Viewport API를 사용한 JS 수동 조정이 현재 가장 신뢰할 수 있는 방법입니다.</p>
            </div>
            
            <!-- 스크롤을 많이 만들기 위한 반복 콘텐츠 -->
            <div class="h-96 bg-gray-50 flex items-center justify-center rounded-xl shadow-inner">
                <p class="text-gray-500">긴 스크롤을 위한 더미 공간 (1)</p>
            </div>
            <div class="bg-white p-4 rounded-xl shadow-md border border-gray-100">
                <h2 class="font-semibold text-lg text-indigo-600">섹션 3: Fixed 요소의 이동</h2>
                <p class="text-sm mt-1">하단의 Fixed UI는 키보드 높이만큼 transform: translateY(-Height)를 사용하여 GPU 가속으로 부드럽게 이동합니다.</p>
            </div>
            <div class="h-96 bg-gray-50 flex items-center justify-center rounded-xl shadow-inner">
                <p class="text-gray-500">긴 스크롤을 위한 더미 공간 (2)</p>
            </div>
            <div class="bg-white p-4 rounded-xl shadow-md border border-gray-100">
                <h2 class="font-semibold text-lg text-indigo-600">섹션 4: 입력 필드</h2>
                <p class="text-sm mt-1">여기에 포커스 시 하단 Fixed UI가 키보드 위로 올라가야 합니다.</p>
            </div>
            
            <!-- 가장 아래에 있는 Input Field -->
            <div class="p-4 bg-yellow-100 rounded-xl">
                 <label for="last_input" class="block mb-2 font-medium text-gray-700">마지막 입력 필드 (화면 하단 근접)</label>
                 <input type="text" id="last_input" placeholder="여기에 입력 시 키보드에 가려질 위험이 큽니다."
                        class="w-full p-3 border-2 border-yellow-400 rounded-lg focus:outline-none focus:ring-4 focus:ring-yellow-300">
            </div>

            <div class="h-32"></div> <!-- 하단 여백 -->
        </div>
    </main>

    <!-- Fixed UI 컨테이너 (JS로 위치 보정 대상) -->
    <div id="fixed-container" class="bg-white border-t-4 border-indigo-500 shadow-2xl p-4">
        <!-- 핵심 Fixed UI 요소 (댓글 버튼, 전송 버튼 등) -->
        <div class="fixed-ui-element flex justify-between items-center mb-3">
            <h3 class="text-xl font-bold text-indigo-700">Fixed Bottom UI</h3>
            <button class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150">
                전송
            </button>
        </div>
        
        <!-- 사용자의 주요 입력 필드 (포커스 발생 지점) -->
        <input type="text" id="input-field" placeholder="여기에 입력하세요. (키보드 테스트용)"
               class="w-full p-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500">
    </div>

    <script>
        const fixedContainer = document.getElementById('fixed-container');
        const inputField = document.getElementById('input-field');
        const statusDisplay = document.getElementById('status');
        
        // 1. Visual Viewport API 지원 여부 확인
        if (window.visualViewport) {
            statusDisplay.textContent = 'Visual Viewport API 지원 확인됨.';
            
            // 2. Visual Viewport Resize 이벤트 리스너 등록 (키보드 등장/퇴장 감지)
            window.visualViewport.addEventListener('resize', handleKeyboardResize);
            
            // 3. Input 필드 포커스/블러 이벤트 처리
            inputField.addEventListener('focus', handleFocus);
            inputField.addEventListener('blur', handleBlur);

        } else {
            statusDisplay.textContent = 'Visual Viewport API를 지원하지 않아 JS 조정이 어렵습니다.';
        }

        /**
         * 키보드 등장/퇴장 시 실행되는 핵심 로직 (resize 이벤트)
         */
        function handleKeyboardResize() {
            // 현재 Visual Viewport 높이를 기준으로 키보드 높이 계산
            const currentVisualHeight = window.visualViewport.height;
            const currentInnerHeight = window.innerHeight;
            
            // KeyboardHeight = window.innerHeight (Layout Height) - visualViewport.height (Current Visible Height)
            // Note: 이 계산은 데모용으로, 보고서의 '정확성' 섹션에서 언급된 Layout Viewport 초기 높이 대신 
            // window.innerHeight를 사용했습니다.
            let keyboardHeight = currentInnerHeight - currentVisualHeight;
            
            // 소수점 이하 버림
            keyboardHeight = Math.max(0, Math.floor(keyboardHeight));

            if (keyboardHeight > 0) {
                // [3.1 성능 최적화 반영]
                // 키보드가 열렸으므로 Fixed UI를 키보드 높이만큼 위로 이동 (Transform 사용)
                fixedContainer.style.transform = `translateY(-${keyboardHeight}px)`;

                // [3.1 iOS Safari 충돌 방지 반영]
                // Fixed UI가 움직인 후, input이 실제로 화면 중앙에 보이도록 스크롤 보정
                // iOS Safari의 자동 보정 동작과의 충돌을 피하기 위해 약간의 지연(debounce)을 줍니다.
                if (document.activeElement === inputField) {
                     setTimeout(() => {
                        inputField.scrollIntoView({ behavior: 'smooth', block: 'center' });
                     }, 200); // 200ms 지연
                }
                
                statusDisplay.classList.replace('bg-indigo-500', 'bg-red-500');
                statusDisplay.textContent = `키보드 열림: ${keyboardHeight}px. Fixed UI transform 적용됨.`;
                
            } else {
                // 키보드가 닫혔으므로 Fixed UI 위치 초기화
                fixedContainer.style.transform = 'translateY(0)';
                statusDisplay.classList.replace('bg-red-500', 'bg-indigo-500');
                statusDisplay.textContent = '키보드 닫힘. Fixed UI 위치 초기화.';
            }
        }

        /**
         * Input 포커스 시 처리 (Scroll 시작 유도)
         */
        function handleFocus() {
             // 포커스 시 초기 스크롤을 유도하여 Visual Viewport resize 이벤트를 발생시킵니다.
             // 이것이 없으면 iOS 등에서 키보드가 올라와도 resize 이벤트가 늦게 발생할 수 있습니다.
             setTimeout(() => {
                inputField.scrollIntoView({ behavior: 'smooth', block: 'end' });
             }, 50);
             statusDisplay.textContent = '입력 필드 포커스됨. 키보드 감지 대기...';
        }

        /**
         * Input 블러 시 처리
         */
        function handleBlur() {
            // 키보드가 닫히면 visualViewport resize 이벤트가 발생하여 위치를 자동으로 초기화합니다.
            // 추가적으로 스크롤을 맨 위로 올릴 필요는 없습니다.
        }

        // 초기 로드 시 스크롤을 맨 위로 이동 (테스트 편의를 위해)
        window.scrollTo(0, 0);

    </script>
</body>
</html>