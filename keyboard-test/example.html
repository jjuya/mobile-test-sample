<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>VisualViewport Fixed Optimized Test</title>
        <style>
            /* 1. 기본 스타일 및 Fixed 요소 스타일 */
            body {
                margin: 0;
                padding: 0;
                min-height: 200vh; /* 스크롤 확보 */
                background-color: #f4f4f4;
            }

            /* Fixed Bottom Menu: 키보드 위에 노출되어야 하는 요소 */
            #fixed-bottom-menu {
                position: fixed;
                bottom: 0;
                left: 0;
                width: 100%;
                height: 50px;
                background-color: #007bff;
                color: white;
                text-align: center;
                line-height: 50px;
                font-weight: bold;
                z-index: 999;
            }

            /* 2. 콘텐츠 래퍼 스타일 (핵심 요소) */
            #viewportwrap {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%; /* 초기 높이 */
                background-color: white;

                /* ✨ GPU 가속 유도 및 최적화 */
                will-change: transform;
                /* transition은 버벅임을 유발할 수 있어 0s로 유지하거나 제거 */
            }

            /* 3. 콘텐츠 스타일 */
            .content-area {
                padding: 20px;
            }

            .content-area h2 {
                margin-top: 50px;
            }
        </style>
    </head>
    <body>
        <div id="viewportwrap">
            <div class="content-area">
                <h1>웹뷰 Fixed 요소 테스트 (최적화)</h1>
                <p>
                    이 코드는 **requestAnimationFrame**을 사용하여 스크롤
                    버벅임을 개선했습니다. 키보드를 열고 스크롤해보세요.
                </p>

                <input
                    type="text"
                    placeholder="여기를 클릭하여 키보드를 열어보세요."
                    style="width: 90%; padding: 10px; margin: 50px 0"
                />

                <h2>스크롤을 위한 긴 콘텐츠</h2>
                <p>
                    Lorem ipsum dolor sit amet, consectetur adipiscing elit. ...
                </p>
                <p style="height: 100px"></p>
                <p>
                    Sed do eiusmod tempor incididunt ut labore et dolore magna
                    aliqua. ...
                </p>
                <p style="height: 100px"></p>
                <p>
                    Ut enim ad minim veniam, quis nostrud exercitation ullamco
                    laboris. ...
                </p>
                <p style="height: 100px"></p>
                <p>
                    Duis aute irure dolor in reprehenderit in voluptate velit
                    esse cillum. ...
                </p>
                <p style="height: 100px"></p>
                <p>
                    Excepteur sint occaecat cupidatat non proident, sunt in
                    culpa qui officia. ...
                </p>
                <p style="height: 400px"></p>
                <p>스크롤 끝 부분</p>
            </div>
        </div>

        <div id="fixed-bottom-menu">
            Fixed Bottom Menu: 키보드 위에 위치해야 합니다.
        </div>

        <script>
            // DOM 요소
            const viewportwrap = document.getElementById("viewportwrap");

            // --- 1. OS 체크 함수 ---
            function checkOS() {
                const userAgent =
                    navigator.userAgent || navigator.vendor || window.opera;
                if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
                    return "iOS";
                }
                if (/android/i.test(userAgent) && /chrome/i.test(userAgent)) {
                    return "AndroidChrome";
                }
                return "Other";
            }

            const currentOS = checkOS();
            console.log(`Current OS detected: ${currentOS}`);

            // --- 2. 최적화 변수 및 공통 업데이트 로직 ---
            let isTicking = false; // rAF 쓰로틀링 플래그
            let lastScrollY = 0; // iOS window.scrollY 저장
            let lastViewportScrollY = 0; // Android visualViewport.offsetTop 저장

            /**
             * rAF를 통해 브라우저의 다음 프레임에 맞춰 위치를 업데이트합니다.
             */
            function updateViewportPosition() {
                isTicking = false;

                if (currentOS === "iOS") {
                    // iOS: window scroll 기반 위치 계산
                    let viewportTopGap =
                        visualViewport.pageTop - visualViewport.offsetTop;
                    let translateY = lastScrollY - viewportTopGap;

                    viewportwrap.style.transform = `translateY(${translateY}px)`;

                    // 가상 영역 스크롤 방지 로직
                    const bodyHeight = document.body.offsetHeight;
                    const viewportH = visualViewport.height;

                    if (lastScrollY + viewportH > bodyHeight - 2) {
                        window.scrollTo(0, bodyHeight - viewportH - 1);
                    }
                } else if (currentOS === "AndroidChrome") {
                    // Android Chrome: visualViewport offsetTop 기반 위치 적용
                    viewportwrap.style.transform = `translateY(${lastViewportScrollY}px)`;
                }
            }

            // --- 3. 플랫폼별 스크롤 핸들러 (데이터만 업데이트하고 rAF 예약) ---

            // iOS 환경 스크롤 핸들러 (Window Scroll)
            function handleWindowScroll_iOS() {
                lastScrollY = window.scrollY;

                // rAF가 실행 중이 아니라면 새로 예약 (쓰로틀링)
                if (!isTicking) {
                    window.requestAnimationFrame(updateViewportPosition);
                    isTicking = true;
                }
            }

            // Android Chrome 스크롤 핸들러 (VisualViewport Scroll)
            function handleViewportScroll_AndroidChrome(e) {
                lastViewportScrollY = parseInt(e.target.offsetTop);

                // rAF가 실행 중이 아니라면 새로 예약 (쓰로틀링)
                if (!isTicking) {
                    window.requestAnimationFrame(updateViewportPosition);
                    isTicking = true;
                }
            }

            // --- 4. 메인: 키보드 감지 및 뷰포트 높이 조정 ---

            function viewportResize() {
                if (!window.visualViewport) return;

                const windowInnerHeight = window.innerHeight;
                const viewportHeight = parseInt(visualViewport.height);

                const isKeyboardOn = windowInnerHeight > viewportHeight;

                // 이벤트 리스너를 먼저 정리
                window.removeEventListener("scroll", handleWindowScroll_iOS);
                visualViewport.removeEventListener(
                    "scroll",
                    handleViewportScroll_AndroidChrome
                );
                viewportwrap.style.transform = `translateY(0)`; // 초기화

                if (isKeyboardOn) {
                    console.log("Keyboard ON: Adjusting viewportwrap height.");

                    // 뷰포트 높이 설정
                    viewportwrap.style.height = `${viewportHeight}px`;

                    // 플랫폼에 따라 스크롤 이벤트 등록
                    if (currentOS === "iOS") {
                        window.addEventListener(
                            "scroll",
                            handleWindowScroll_iOS
                        );
                    } else if (currentOS === "AndroidChrome") {
                        visualViewport.addEventListener(
                            "scroll",
                            handleViewportScroll_AndroidChrome
                        );
                    }
                } else {
                    // 키보드 OFF
                    console.log("Keyboard OFF: Resetting viewportwrap.");

                    // 원래 높이로 복원
                    viewportwrap.style.height = "100%";
                }
            }

            // 초기 실행 및 리사이즈 이벤트 리스너 등록
            if (window.visualViewport) {
                visualViewport.addEventListener("resize", viewportResize);
                // 페이지 로드 시 초기 상태 확인
                viewportResize();
            } else {
                console.warn(
                    "VisualViewport API is not supported in this environment."
                );
            }
        </script>
    </body>
</html>
