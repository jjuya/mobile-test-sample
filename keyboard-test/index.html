<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>모바일 키보드 Fixed UI 및 스크롤 테스트 (VisualViewport 반영)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html { font-family: 'Inter', sans-serif; }
        body {
            height: 100vh;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            padding-bottom: 12rem; /* Fixed UI 공간 확보 */
        }

        /* Fixed UI 컨테이너 (JS로 transform 보정 대상) - position: fixed 유지 */
        #fixed-container {
            position: fixed; 
            bottom: 0;
            left: 0;
            right: 0;
            transition: none; 
            z-index: 50;
        }

        /* 키보드 유무 상태 메시지 - 상단 고정 유지 (JS로 위치 보정 대상) */
        #status {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 60;
            font-size: 0.875rem;
            transition: none; 
        }
    </style>
</head>
<body>

    <div id="status" class="bg-indigo-500 text-white p-2 text-center shadow-lg">
        Visual Viewport 상태 모니터링 중...
    </div>
    
    <main class="container mx-auto px-4 py-12 flex-grow">
        <h1 class="text-3xl font-bold mb-4 text-gray-800">스크롤 가능한 콘텐츠 영역</h1>
        
        <div class="space-y-4">
            <div class="bg-white p-4 rounded-xl shadow-md border border-gray-100">
                <h2 class="font-semibold text-lg text-indigo-600">섹션 1: Fixed UI 안정화 로직</h2>
                <p class="text-sm mt-1">브라우저 기본 동작(`resizes-visual`)에서 JS 보정(`keyboardHeight + offsetTop`)을 통해 Fixed UI를 VV에 앵커링합니다.</p>
            </div>
            
            <div class="h-96 bg-gray-50 flex items-center justify-center rounded-xl shadow-inner">
                <p class="text-gray-500">긴 스크롤을 위한 더미 공간 (1)</p>
            </div>
            
            <div class="h-96 bg-gray-50 flex items-center justify-center rounded-xl shadow-inner">
                <p class="text-gray-500">긴 스크롤을 위한 더미 공간 (2)</p>
            </div>
            
            <div class="p-4 bg-yellow-100 rounded-xl">
                <label for="last_input" class="block mb-2 font-medium text-gray-700">마지막 입력 필드 (화면 하단 근접)</label>
                <input type="text" id="last_input" placeholder="여기에 입력 시 키보드에 가려질 위험이 큽니다." class="w-full p-3 border-2 border-yellow-400 rounded-lg focus:outline-none focus:ring-4 focus:ring-yellow-300">
            </div>

            <div class="h-32"></div> </div>
    </main>

    <div id="fixed-container" class="bg-white border-t-4 border-indigo-500 shadow-2xl p-4">
        <div class="fixed-ui-element flex justify-between items-center mb-3">
            <h3 class="text-xl font-bold text-indigo-700">Fixed Bottom UI</h3>
            <button class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150">
                전송
            </button>
        </div>
        
        <input type="text" id="input-field" placeholder="Fixed UI 내 입력 (키보드 테스트용)" class="w-full p-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500">
    </div>

    <script>
        const fixedContainer = document.getElementById('fixed-container');
        const lastInputField = document.getElementById('last_input');
        const allInputs = document.querySelectorAll('input[type="text"]');
        const statusDisplay = document.getElementById('status');
        const safetyMargin = 15; // 입력 필드와 키보드/Fixed UI 사이에 확보할 최소 여백 (px)

        // 키보드 높이 계산 (Layout Viewport 높이 - Visual Viewport 높이)
        function getKeyboardHeight() {
            const keyboardHeight = window.innerHeight - (window.visualViewport?.height?? window.innerHeight);
            return Math.max(0, Math.floor(keyboardHeight));
        }

        // Fixed UI 위치 보정 및 상태 업데이트
        function handleFixedElementCorrection() {
            if (!window.visualViewport) return;

            const keyboardHeight = getKeyboardHeight();
            // Layout Viewport에 대한 Visual Viewport의 오프셋 (스크롤 시 변경됨)
            const offsetTop = window.visualViewport.offsetTop?? 0; 
            
            // 1. 상단 Fixed UI (#status) 보정: offsetTop만큼 아래로 내려 VV 상단에 앵커링
            if (statusDisplay) {
                statusDisplay.style.transform = `translateY(${offsetTop}px)`;
            }

            // 2. 하단 Fixed UI (#fixed-container) 보정
            if (fixedContainer) {
                if (keyboardHeight > 0) {
                    // 키보드 높이 + LV 스크롤 오프셋을 합쳐 LV 스크롤을 상쇄하고 키보드 위에 고정
                    const totalTransformBottom = keyboardHeight + offsetTop; 
                    fixedContainer.style.transform = `translateY(-${totalTransformBottom}px)`;
                    
                    statusDisplay.classList.replace('bg-indigo-500', 'bg-red-500');
                    statusDisplay.textContent = `키보드 열림: ${keyboardHeight}px. OffsetTop: ${Math.floor(offsetTop)}px. Fixed UI 고정됨.`;
                } else {
                    // 키보드 닫힘 시 위치 초기화
                    fixedContainer.style.transform = 'translateY(0)';
                    statusDisplay.classList.replace('bg-red-500', 'bg-indigo-500');
                    statusDisplay.textContent = '키보드 닫힘. Fixed UI 위치 초기화.';
                }
            }
        }
        
        // 스크롤 가능한 입력 필드 위치를 VV 중앙으로 강제 보정
        function scrollToInputIntoView(inputElement) {
            
            // Fixed UI 보정 및 OSK 애니메이션 대기 (350ms)
            setTimeout(() => {
                if (!window.visualViewport || getKeyboardHeight() === 0) return;

                const inputRect = inputElement.getBoundingClientRect();
                
                const bottomFixedElementHeight = fixedContainer.offsetHeight;

                // 목표 위치 계산: VV 높이 - 키보드 - Fixed UI - 마진
                const targetInputBottomVV = window.visualViewport.height - getKeyboardHeight() - bottomFixedElementHeight - safetyMargin;
                
                const currentInputBottomVV = inputRect.bottom;
                
                // 스크롤 필요 거리 계산
                const distanceToScroll = currentInputBottomVV - targetInputBottomVV;

                if (distanceToScroll > 0) {
                    // LV 스크롤 실행
                    const newScrollY = window.scrollY + distanceToScroll;
                    
                    window.scrollTo({
                        top: newScrollY,
                        // 즉시 스크롤하여 Fixed UI의 잔 떨림 방지
                        behavior: 'instant' 
                    });
                }
                
            }, 350); 
        }
        
        // Visual Viewport 및 Layout 스크롤 이벤트 리스너 등록
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', handleFixedElementCorrection);
            window.visualViewport.addEventListener('scroll', handleFixedElementCorrection);
            
            document.addEventListener('scroll', handleFixedElementCorrection);

            function handleFocus(event) {
                // Fixed UI 보정 선행
                setTimeout(handleFixedElementCorrection, 50);

                const targetId = event.target.id;
                
                if (targetId === 'last_input') {
                    // 스크롤 보정 실행
                    scrollToInputIntoView(event.target);
                } 
            }
            
            allInputs.forEach(input => input.addEventListener('focus', handleFocus));
        
        } else {
            statusDisplay.classList.replace('bg-indigo-500', 'bg-red-700');
            statusDisplay.textContent = 'Visual Viewport API를 지원하지 않아 JS 조정이 어렵습니다.';
        }

        // 초기화
        window.scrollTo(0, 0);
        handleFixedElementCorrection();
    </script>
</body>
</html>