<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>모바일 키보드 Fixed UI 및 모달 테스트 (VisualViewport 반영)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html { font-family: 'Inter', sans-serif; }
        body {
            height: 100vh;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            padding-bottom: 12rem; /* Fixed UI 공간 확보 */
        }

        /* Fixed UI 컨테이너 (JS로 transform 보정 대상) */
        #fixed-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            transition: none; /* JS 위치 업데이트가 즉시 반영되도록 transition 제거 */
            z-index: 50;
        }

        /* 키보드 유무 상태 메시지 - 상단 고정 유지 (JS로 위치 보정 대상) */
        #status {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 60;
            font-size: 0.875rem;
            transition: none; /* JS 위치 업데이트가 즉시 반영되도록 transition 제거 */
        }

        /* 모달 컨테이너 (처음에는 숨김) */
        #modal-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: none; /* 초기 숨김 */
            justify-content: center;
            align-items: center;
            z-index: 1000;
            /* OSK 활성화 시 이 요소의 height가 visualViewport.height로 조정됨 */
            height: 100vh; 
        }

        #modal-container.is-open {
            display: flex;
        }

        /* 모달 콘텐츠 (중앙 정렬) */
        #modal-content {
            background: white;
            padding: 20px;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            /* 모달 내부는 스크롤 가능하게 설정 */
            max-height: 90%; 
            overflow-y: auto;
        }
    </style>
</head>
<body>

    <div id="status" class="bg-indigo-500 text-white p-2 text-center shadow-lg">
        Visual Viewport 상태 모니터링 중...
    </div>
    
    <main class="container mx-auto px-4 py-12 flex-grow">
        <h1 class="text-3xl font-bold mb-4 text-gray-800">스크롤 가능한 콘텐츠 영역</h1>
        
        <button id="open-modal-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg shadow-xl mb-6">
            모달 열고 입력창 테스트
        </button>

        <div class="space-y-4">
            <div class="bg-white p-4 rounded-xl shadow-md border border-gray-100">
                <h2 class="font-semibold text-lg text-indigo-600">섹션 1: Viewport 문제의 이해</h2>
                <p class="text-sm mt-1">이 페이지는 Fixed UI 보정 (하단바) 및 스크롤 필드 보정 (#last_input) 로직을 테스트합니다. 모달창 테스트는 '모달 열기' 버튼을 이용하세요.</p>
            </div>
            
            <div class="h-96 bg-gray-50 flex items-center justify-center rounded-xl shadow-inner">
                <p class="text-gray-500">긴 스크롤을 위한 더미 공간 (1)</p>
            </div>
            
            <div class="h-96 bg-gray-50 flex items-center justify-center rounded-xl shadow-inner">
                <p class="text-gray-500">긴 스크롤을 위한 더미 공간 (2)</p>
            </div>
            
            <div class="p-4 bg-yellow-100 rounded-xl">
                <label for="last_input" class="block mb-2 font-medium text-gray-700">마지막 입력 필드 (화면 하단 근접)</label>
                <input type="text" id="last_input" placeholder="여기에 입력 시 키보드에 가려질 위험이 큽니다." class="w-full p-3 border-2 border-yellow-400 rounded-lg focus:outline-none focus:ring-4 focus:ring-yellow-300">
            </div>

            <div class="h-32"></div> </div>
    </main>

    <div id="fixed-container" class="bg-white border-t-4 border-indigo-500 shadow-2xl p-4">
        <div class="fixed-ui-element flex justify-between items-center mb-3">
            <h3 class="text-xl font-bold text-indigo-700">Fixed Bottom UI</h3>
            <button class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150">
                전송
            </button>
        </div>
        
        <input type="text" id="input-field" placeholder="Fixed UI 내 입력 (키보드 테스트용)" class="w-full p-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500">
    </div>

    <div id="modal-container" onclick="if(event.target.id === 'modal-container') closeModal();">
        <div id="modal-content">
            <h2 class="text-2xl font-bold mb-4 text-indigo-700">모달 내 입력 테스트</h2>
            <p class="mb-4 text-gray-600">이 모달은 키보드 활성화 시 Visual Viewport의 크기에 맞춰 높이가 조정됩니다.</p>
            
            <label for="modal-input" class="block mb-2 font-medium text-gray-700">모달 입력 필드 1</label>
            <input type="text" id="modal-input" placeholder="모달 내 입력 (키보드 보정 대상)" class="w-full p-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 mb-4">
            
            <label for="modal-input-2" class="block mb-2 font-medium text-gray-700">모달 입력 필드 2</label>
            <input type="text" id="modal-input-2" placeholder="모달 내 입력 2 (스크롤 유도)" class="w-full p-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 mb-20">
            
            <button onclick="closeModal()" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">
                닫기
            </button>
        </div>
    </div>

    <script>
        const fixedContainer = document.getElementById('fixed-container');
        const lastInputField = document.getElementById('last_input');
        const modalContainer = document.getElementById('modal-container');
        const openModalBtn = document.getElementById('open-modal-btn');
        const allInputs = document.querySelectorAll('input[type="text"]');
        const statusDisplay = document.getElementById('status');
        const safetyMargin = 15; // 입력 필드와 Fixed UI/키보드 사이에 확보할 최소 여백 (px)

        /**
         * 모바일 가상 키보드가 차지하는 높이를 계산합니다.
         * @returns {number} 키보드 높이 (CSS 픽셀)
         */
        function getKeyboardHeight() {
            // Layout Viewport (window.innerHeight)와 Visual Viewport (window.visualViewport.height)의 차이
            if (window.visualViewport) {
                return window.innerHeight - window.visualViewport.height;
            }

            return 0;
        }

        /**
         * Fixed 요소 위치 조정 및 모달 높이/위치 조정
         * 이 함수는 Visual Viewport의 resize, scroll 이벤트에 반응하여 실행됩니다.
         */
        function handleFixedElementCorrection() {
            if (!window.visualViewport) return;
            
            const keyboardHeight = getKeyboardHeight();

            // Layout Viewport(LV)에 대한 Visual Viewport(VV)의 offsetTop 값
            const offsetTop = window.visualViewport.offsetTop || 0;

            if (statusDisplay) {
                // 상단 Fixed 요소가 LV 스크롤에 의해 밀려 올라가는 것을 방지하기 위해,
                // offsetTop 만큼 아래로 내려서 VV 상단에 앵커링되도록 보정합니다.
                statusDisplay.style.transform = `translateY(${offsetTop}px)`;
            }

            if (fixedContainer) {
                if (keyboardHeight > 0) {
                    // 하단 Fixed UI는 'bottom: 0'을 기준으로 하므로,
                    // 키보드 높이만큼만 올려줍니다. offsetTop을 더하면 스크롤 시 밀려 올라갑니다.
                    fixedContainer.style.transform = `translateY(-${keyboardHeight}px)`;

                    statusDisplay.classList.replace('bg-indigo-500', 'bg-red-500');
                    statusDisplay.textContent = `키보드 열림: ${keyboardHeight}px. OffsetTop: ${offsetTop}px. 상/하 Fixed UI 고정됨.`;
                }
            } else {
                fixedContainer.style.transform = 'translateY(0)';
                statusDisplay.classList.replace('bg-red-500', 'bg-indigo-500');
                statusDisplay.textContent = '키보드 닫힘. Fixed UI 위치 초기화.';
            }
        }


        function handleInputFocus(event) {
            // 1. Fixed UI 위치 보정 시작 (키보드 높이 감지)
            // 키보드가 올라오면서 Fixed UI의 위치가 조정될 시간을 줍니다.
            setTimeout(handleFixedElementCorrection, 50);

            const targetId = event.target.id;

            // 스크롤 가능한 콘텐츠 내 입력 필드 (#last_input)만 스크롤 보정을 실행합니다.
            if (targetId === 'last_input') {
                scrollToInputIntoView(event.target, false);
            }

            statusDisplay.textContent = '입력 필드 포커스됨. 키보드 감지 중...';
        }

        /**
         * 입력 필드가 키보드 위에 보이도록 Layout/모달 스크롤 위치를 정밀하게 보정합니다.
         * 이 로직은 scrollIntoView()의 신뢰성 문제(요소가 이미 보인다고 오판하여 스크롤 안 함)를 우회합니다.
         * @param {HTMLElement} inputElement - 스크롤 보정 대상 입력 필드
         * @param {boolean} isModalInput - 모달 내부 입력 필드인지 여부
         */
        function scrollToInputIntoView(inputElement, isModalInput = false) {
            setTimeout(() => {
                if (!window.visualViewport || getKeyboardHeight() === 0) return;

                const inputRect = inputElement.getBoundingClientRect();

                // 모달 내부가 아닐 경우, 하단 Fixed UI의 높이를 고려
                const bottomFixedElementHeight = isModalInput ? 0 : bottomFixedElementHeight = fixedContainer.offsetHeight;

                // 1. Visual Viewport 내에서 입력 필드의 이상적인 '하단' 위치 계산:
                // 목표 위치 = VV 높이 - 키보드 높이 - Fixed UI 높이 - 안전 여백
                const targetInputBottomVV = window.visualViewport.height - getKeyboardHeight() - bottomFixedElementHeight - safetyMargin;

                // 2. 현재 입력 필드의 '하단' 위치 (Visual Viewport 기준)
                const currentInputBottomVV = inputRect.bottom;

                // 3. 목표 위치에 도달하기 위해 필요한 스크롤 거리 계산
                // 현재 위치(currentInputBottomVV)가 목표 위치(targetInputBottomVV)보다 크면, 스크롤이 필요합니다.
                const distanceToScroll = currentInputBottomVV - targetInputBottomVV;

                if (distanceToScroll > 0) {
                    if (!isModalInput) {
                        const newScrollY = window.scrollY + distanceToScroll;

                        window.scrollTo({
                            top: newScrollY,
                            behavior: 'smooth'
                        })
                    } else {
                        const modalContent = document.getElementById('modal-content');

                        if (modalContent) {
                            modalContent.scrollTop += distanceToScroll;
                        }
                    }
                }
            }, 250)

        }

        if (window.visualViewport) {
            // Visual Viewport 이벤트: 키보드 크기/스크롤 변화 감지 [2]
            window.visualViewport.addEventListener('resize', handleFixedElementCorrection);
            window.visualViewport.addEventListener('scroll', handleFixedElementCorrection);
            
            // Layout Viewport 스크롤 중에도 Fixed UI가 고정된 것처럼 보이도록 보조
            document.addEventListener('scroll', handleFixedElementCorrection);
        }

        allInputs.forEach(input => input.addEventListener('focus', handleInputFocus));

        // 초기 로드 시 스크롤 위치 초기화 및 Fixed UI 초기 보정
        window.scrollTo(0, 0);
        handleFixedElementCorrection();
    </script>
</body>
</html>